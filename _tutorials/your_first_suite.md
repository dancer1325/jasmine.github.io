---
# This file was generated by locco from _tutorials/src/your_first_suite.js. Do not edit it directly!
layout: tutorial
redirect_from:
    - "/edge/your_first_suite.html"
    - "/edge/introduction.html"
include_docco: true
file_name: "your_first_suite"
---

# Suites -- `function describe(description String, specDefinitions) {}` -- 
* describe your tests /
  * NORMALLY, 1 suite / file
* `function describe(description: String, specDefinitions) {}`
  * allows
    * grouping related specs
  * `description`
    * allows
      * naming the collection of specs
    * uses
      * \+ `specs` == [traditional BDD full name](http://en.wikipedia.org/wiki/Behavior-driven_development) 
      * find specs | large suite

# Specs -- `it(description: String, testFunction, timeout){}` --
* == global Jasmine function
* `description`,
  * == spec's title
* `testFunction`
  * ðŸ‘€== spec, or test ðŸ‘€
  * == >=1 expectations
    * if ALL expectations pass -> passing spec
    * if >=1 expectations are false -> failing spec 
    * expectation
      * == assertion / it's true or false 

## Just Functions
* `describe` & `it` blocks 
  * -- contain -- any executable code necessary / implement the test
    * Reason: ðŸ§ they are functions ðŸ§  
  * ðŸ‘€JavaScript scoping rules apply ðŸ‘€
    * == variables / declared | `describe` -> AVAILABLE | any `it` block

# Expectations -- `expect(actual).matcherFunction()`

## Matchers
* implements a boolean comparison : actual value vs expected value /
  * report the -- result comparison to -- Jasmine / pass or fail the spec

* `.not.`
  * allows
    * evaluating to a negative assertion

* see 
  * [built-in matchers](/_api/edge/matchers.md)
  * [custom matchers](custom_matchers.md)

## Setup and Teardown

* goal
  * test suite DRY up any duplicated setup & teardown code

* -- via --
  * `beforeEach`
    * == run BEFORE EACH `describe`'s `it`
  * `afterEach`
    * == run AFTER EACH `describe`'s `it`
  * `beforeAll`
    * == run BEFORE ALL `describe`'s `it`
  * `afterAll`
    * == run AFTER ALL `describe`'s `it`

## `this` 
* allows
  * sharing variables between `beforeEach` -- `it` -- `afterEach`
    * Reason: ðŸ§ EACH `beforeEach` / `it` / `afterEach` 's `this` == empty object ðŸ§ 
    * requirements
      * ðŸ‘€use the `function` keyword, rather than arrow functions ðŸ‘€

## Manually failing a spec with fail
* TODO:
<p>The fail function causes a spec to fail. It can take a failure message or
an Error object as a parameter.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    describe("A spec using the fail function", function() {
        function foo(x, callBack) {
            if (x) {
                callBack();
            }
        }

        it("should not call the callBack", function() {
            foo(false, function() {
                fail("Callback has been called");
            });
        });
    });
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Nesting_describe_Blocks">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Nesting_describe_Blocks">&#182;</a>
      </div>

## Nesting <code>describe</code> Blocks
<p>Calls to <code>describe</code> can be nested, with specs defined at any level. This
allows a suite to be composed as a tree of functions. Before a spec is
executed, Jasmine walks down the tree executing each <code>beforeEach</code> function
in order. After the spec is executed, Jasmine walks through the
<code>afterEach</code> functions similarly.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    describe("A spec", function() {
        let foo;

        beforeEach(function() {
            foo = 0;
            foo += 1;
        });

        afterEach(function() {
            foo = 0;
        });

        it("is just a function, so it can contain any code", function() {
            expect(foo).toEqual(1);
        });

        it("can have more than one expectation", function() {
            expect(foo).toEqual(1);
            expect(true).toEqual(true);
        });

        describe("nested inside a second describe", function() {
            let bar;

            beforeEach(function() {
                bar = 1;
            });

            it("can reference both scopes as needed", function() {
                expect(foo).toEqual(bar);
            });
        });
    });
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Disabling_Suites">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Disabling_Suites">&#182;</a>

## Disabling Suites
<p>Suites can be disabled with the <code>xdescribe</code> function. These suites and any
specs inside them are skipped when run and thus their results will show as
pending.</p>
<p>Suites can also be focused with the <code>fdescribe</code> function. That means only
<code>fdescribe</code> suits will run.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    xdescribe("A spec", function() {
        let foo;

        beforeEach(function() {
            foo = 0;
            foo += 1;
        });

        it("is just a function, so it can contain any code", function() {
            expect(foo).toEqual(1);
        });
    });
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Pending_Specs">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Pending_Specs">&#182;</a>
      </div>

## Pending Specs
<p>Pending specs do not run, but their names will show up in the results as
pending.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    describe("Pending specs", function() { {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Any_spec_declared_with_xit_is_marked_as_pending">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Any_spec_declared_with_xit_is_marked_as_pending">&#182;</a>
      </div>
      <div>
        <p>Any spec declared with <code>xit</code> is marked as pending.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}        xit("can be declared 'xit'", function() {
            expect(true).toBe(false);
        });
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Any_spec_declared_without_a_function_body_will_also_be_marked_pending">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Any_spec_declared_without_a_function_body_will_also_be_marked_pending">&#182;</a>
      </div>
      <div>
        <p>Any spec declared without a function body will also be marked pending
in results.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}        it("can be declared with 'it' but without a function");
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-And_if_you_call_the_function_pending_anywhere_in_the_spec_body,">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-And_if_you_call_the_function_pending_anywhere_in_the_spec_body,">&#182;</a>
      </div>
      <div>
        <p>And if you call the function <code>pending</code> anywhere in the spec body,
no matter the expectations, the spec will be marked pending. A string
passed to <code>pending</code> will be treated as a reason and displayed when the
suite finishes.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}        it("can be declared by calling 'pending' in the spec body", function() {
            expect(true).toBe(false);
            pending('this is why it is pending');
        });
    });
});
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Tests_can_also_be_focused_with_the_fit_function_That_means_only_fit_tests">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Tests_can_also_be_focused_with_the_fit_function_That_means_only_fit_tests">&#182;</a>
      </div>
      <div>
        <p>Tests can also be focused with the <code>fit</code> function. That means only <code>fit</code> tests
will run.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Asynchronous_Support">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Asynchronous_Support">&#182;</a>
      </div>
      <div>

# Asynchronous Support
<p>Jasmine also has support for running specs that require testing
asynchronous operations. The functions that you pass to <code>beforeAll</code>,
<code>afterAll</code>, <code>beforeEach</code>, <code>afterEach</code>, and <code>it</code> can be declared async.</p>
<p>Jasmine also supports asynchronous functions that explicitly return
promises or that take a callback. See the
<a href="/tutorials/async">Asynchronous Work tutorial</a> for more information.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}describe("Using async/await", function () {
    beforeEach(async function () {
        await soon();
        value = 0;
    });
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-This_spec_will_not_start_until_the_promise_returned_from_the_call_to">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-This_spec_will_not_start_until_the_promise_returned_from_the_call_to">&#182;</a>
      </div>
      <div>
        <p>This spec will not start until the promise returned from the call to
<code>beforeEach</code> above is settled. And this spec will not complete until
the promise that it returns is settled.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    it("supports async execution of test preparation and expectations",
        async function () {
            await soon();
            value++;
            expect(value).toBeGreaterThan(0);
        }
    );

    function soon() {
        return new Promise(function(resolve, reject) {
            setTimeout(function() {
                resolve();
            }, 1);
        });
    }
});

 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-By_default_jasmine_will_wait_for_5_seconds_for_an_asynchronous_spec_to">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-By_default_jasmine_will_wait_for_5_seconds_for_an_asynchronous_spec_to">&#182;</a>
      </div>
      <div>
        <p>By default jasmine will wait for 5 seconds for an asynchronous spec to
finish before causing a timeout failure. If the timeout expires before
<code>done</code> is called, the current spec will be marked as failed and suite
execution will continue as if <code>done</code> was called.</p>
<p>If specific specs should fail faster or need more time this can be
adjusted by passing a timeout value to <code>it</code>, etc.</p>
<p>If the entire suite should have a different timeout,
<code>jasmine.DEFAULT_TIMEOUT_INTERVAL</code> can be set globally, outside of any
given describe.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}describe("long asynchronous specs", function() {
    beforeEach(async function() {
        await somethingSlow();
    }, 1000);

    it("takes a long time", async function() {
        await somethingReallySlow();
    }, 10000);

    afterEach(async function() {
        await somethingSlow();
    }, 1000);
});
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Spies">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Spies">&#182;</a>
      </div>
      <div>

# Spies
<p>Jasmine has test double functions called <a href="/api/edge/Spy.html">spies</a>. A spy
can stub any function and tracks calls to it and all arguments. A spy only
exists in the <code>describe</code> or <code>it</code> block in which it is defined, and will be
removed after each spec. There are special matchers for interacting with spies.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}describe("A spy", function() {
    let foo;
    let bar = null;

    beforeEach(function() {
        foo = {
            setBar: function (value) {
                bar = value;
            }
        };
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-You_can_define_what_the_spy_will_do_when_invoked_with">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-You_can_define_what_the_spy_will_do_when_invoked_with">&#182;</a>
      </div>
      <div>
        <p>You can define what the spy will do when invoked with
<a href="/api/edge/Spy.html#and">and</a>.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}        spyOn(foo, 'setBar');

        foo.setBar(123);
        foo.setBar(456, 'another param');
    });
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-The_toHaveBeenCalled_matcher_will_pass_if_the_spy_was_called">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-The_toHaveBeenCalled_matcher_will_pass_if_the_spy_was_called">&#182;</a>
      </div>
      <div>
        <p>The <code>toHaveBeenCalled</code> matcher will pass if the spy was called.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    it("tracks that the spy was called", function() {
        expect(foo.setBar).toHaveBeenCalled();
    });
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-The_toHaveBeenCalledTimes_matcher_will_pass_if_the_spy_was_called_the">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-The_toHaveBeenCalledTimes_matcher_will_pass_if_the_spy_was_called_the">&#182;</a>
      </div>
      <div>
        <p>The <code>toHaveBeenCalledTimes</code> matcher will pass if the spy was called the
specified number of times.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    it("tracks that the spy was called x times", function() {
        expect(foo.setBar).toHaveBeenCalledTimes(2);
    });
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-The_toHaveBeenCalledWith_matcher_will_return_true_if_the_argument_list">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-The_toHaveBeenCalledWith_matcher_will_return_true_if_the_argument_list">&#182;</a>
      </div>
      <div>
        <p>The <code>toHaveBeenCalledWith</code> matcher will return true if the argument list
matches any of the recorded calls to the spy.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    it("tracks all the arguments of its calls", function() {
        expect(foo.setBar).toHaveBeenCalledWith(123);
        expect(foo.setBar).toHaveBeenCalledWith(456, 'another param');
    });
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-You_get_all_of_the_data_that_a_spy_tracks_about_its_calls_with">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-You_get_all_of_the_data_that_a_spy_tracks_about_its_calls_with">&#182;</a>
      </div>
      <div>
        <p>You get all of the data that a spy tracks about its calls with
<a href="/api/edge/Spy_calls.html">calls</a>.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    it("tracks if it was called at all", function() {
        foo.setBar();

        expect(foo.setBar.calls.any()).toEqual(true);
    });
});
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Spies:_createSpy">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Spies:_createSpy">&#182;</a>
      </div>
      
## Spies: <code>createSpy</code>
<p>When there is not a function to spy on, <code>jasmine.createSpy</code> can create a
&quot;bare&quot; spy. This spy acts as any other spy - tracking calls, arguments, etc.
But there is no implementation behind it.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}describe("A spy, when created manually", function() {
    let whatAmI;

    beforeEach(function() {
        whatAmI = jasmine.createSpy('whatAmI');

        whatAmI("I", "am", "a", "spy");
    });

    it("tracks that the spy was called", function() {
        expect(whatAmI).toHaveBeenCalled();
    });
});
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Spies:_createSpyObj">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Spies:_createSpyObj">&#182;</a>
      </div>

## Spies: <code>createSpyObj</code>
<p>In order to create a mock with multiple spies, use
<a href="/api/edge/jasmine.html#.createSpyObj">jasmine.createSpyObj</a> and pass an array
of strings. It returns an object that has a property for each string that is a
spy.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}describe("Multiple spies, when created manually", function() {
    let tape;

    beforeEach(function() {
        tape = jasmine.createSpyObj(
            'tape',
            ['play', 'pause', 'stop', 'rewind']
        );

        tape.play();
        tape.pause();
        tape.rewind(0);
    });

    it("creates spies for each requested function", function() {
        expect(tape.play).toBeDefined();
        expect(tape.pause).toBeDefined();
        expect(tape.stop).toBeDefined();
        expect(tape.rewind).toBeDefined();
    });
});
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Matching_with_more_finesse">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Matching_with_more_finesse">&#182;</a>
      </div>
      <div>

# Matching with more finesse
<p>Sometimes you don&#39;t want to match with exact equality. Jasmine provides a
number of asymmetric equality testers.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}describe("Matching with finesse", function() { {% endhighlight %}
    </td>
  </tr>
  <tr id="section-jasmineanyapiedgejasminehtmlany_takes_a_constructor_or_class">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-jasmineanyapiedgejasminehtmlany_takes_a_constructor_or_class">&#182;</a>
      </div>
      <div>
        <p><a href="/api/edge/jasmine.html#.any">jasmine.any</a> takes a constructor or &quot;class&quot;
name as an expected value. It returns <code>true</code> if the constructor matches the
constructor of the actual value.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    describe("jasmine.any", function () {
        it("matches any value", function () {
            expect({}).toEqual(jasmine.any(Object));
            expect(12).toEqual(jasmine.any(Number));
        });

        describe("when used with a spy", function () {
            it("is useful for comparing arguments", function () {
                const foo = jasmine.createSpy('foo');
                foo(12, function () {
                    return true;
                });

                expect(foo).toHaveBeenCalledWith(
                    jasmine.any(Number), jasmine.any(Function)
                );
            });
        });
    });
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-jasmineanythingapiedgeglobalhtmlanything_returns_true_if_the">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-jasmineanythingapiedgeglobalhtmlanything_returns_true_if_the">&#182;</a>
      </div>
      <div>
        <p><a href="/api/edge/global.html#.anything">jasmine.anything</a> returns <code>true</code> if the
actual value is not <code>null</code> or <code>undefined</code>.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    describe("jasmine.anything", function () {
        it("matches anything", function () {
            expect(1).toEqual(jasmine.anything());
        });

        describe("when used with a spy", function () {
            it("is useful when the argument can be ignored", function () {
                const foo = jasmine.createSpy('foo');
                foo(12, function () {
                    return false;
                });

                expect(foo).toHaveBeenCalledWith(12, jasmine.anything());
            });
        });
    });
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-jasmineobjectContainingapiedgeglobalhtmlobjectContaining_is_for">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-jasmineobjectContainingapiedgeglobalhtmlobjectContaining_is_for">&#182;</a>
      </div>
      <div>
        <p><a href="/api/edge/global.html#.objectContaining">jasmine.objectContaining</a> is for
those times when an expectation only cares about certain key/value pairs
in the actual.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    describe("jasmine.objectContaining", function () {
        let foo;

        beforeEach(function () {
            foo = {
                a: 1,
                b: 2,
                bar: "baz"
            };
        });

        it("matches objects with the expect key/value pairs", function () {
            expect(foo).toEqual(jasmine.objectContaining({
                bar: "baz"
            }));
            expect(foo).not.toEqual(jasmine.objectContaining({
                c: 37
            }));
        });

        describe("when used with a spy", function () {
            it("is useful for comparing arguments", function () {
                const callback = jasmine.createSpy('callback');

                callback({
                    bar: "baz"
                });

                expect(callback).toHaveBeenCalledWith(
                    jasmine.objectContaining({bar: "baz"})
                );
            });
        });
    });
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-jasminearrayContainingapiedgeglobalhtmlarrayContaining_is_for">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-jasminearrayContainingapiedgeglobalhtmlarrayContaining_is_for">&#182;</a>
      </div>
      <div>
        <p>[jasmine.arrayContaining](/api/edge/global.html#.arrayContaining is for
those times when an expectation only cares about some of the values in an
array.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    describe("jasmine.arrayContaining", function () {
        let foo;

        beforeEach(function () {
            foo = [1, 2, 3, 4];
        });

        it("matches arrays with some of the values", function () {
            expect(foo).toEqual(jasmine.arrayContaining([3, 1]));
            expect(foo).not.toEqual(jasmine.arrayContaining([6]));
        });

        describe("when used with a spy", function () {
            it("is useful when comparing arguments", function () {
                const callback = jasmine.createSpy('callback');

                callback([1, 2, 3, 4]);

                expect(callback).toHaveBeenCalledWith(
                    jasmine.arrayContaining([4, 2, 3])
                );
                expect(callback).not.toHaveBeenCalledWith(
                    jasmine.arrayContaining([5, 2])
                );
            });
        });
    });
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-jasminestringMatchingapiedgeglobalhtmlstringMatching_is_for">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-jasminestringMatchingapiedgeglobalhtmlstringMatching_is_for">&#182;</a>
      </div>

## <a href="/api/edge/global.html#.stringMatching">jasmine.stringMatching</a> is for
<p>when you don&#39;t want to match a string in a larger object exactly, or match
a portion of a string in a spy expectation.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    describe('jasmine.stringMatching', function () {
        it("matches as a regexp", function () {
            expect({foo: 'bar'}).toEqual({
                foo: jasmine.stringMatching(/^bar$/)
            });
            expect({foo: 'foobarbaz'}).toEqual({
                foo: jasmine.stringMatching('bar')
            });
        });

        describe("when used with a spy", function () {
            it("is useful for comparing arguments", function () {
                const callback = jasmine.createSpy('callback');

                callback('foobarbaz');

                expect(callback).toHaveBeenCalledWith(
                    jasmine.stringMatching('bar')
                );
                expect(callback).not.toHaveBeenCalledWith(
                    jasmine.stringMatching(/^bar$/)
                );
            });
        });
    });
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Custom_asymmetric_equality_tester">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Custom_asymmetric_equality_tester">&#182;</a>
      </div>
      
## Custom asymmetric equality tester
<p>When you need to check that something meets a certain criteria, without
being strictly equal, you can also specify a custom asymmetric equality
tester simply by providing an object that has an <code>asymmetricMatch</code> function.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    describe("custom asymmetry", function () {
        const tester = {
            asymmetricMatch: function (actual) {
                const secondValue = actual.split(',')[1];
                return secondValue === 'bar';
            }
        };

        it("dives in deep", function () {
            expect("foo,bar,baz,quux").toEqual(tester);
        });

        describe("when used with a spy", function () {
            it("is useful for comparing arguments", function () {
                const callback = jasmine.createSpy('callback');

                callback('foo,bar,baz');

                expect(callback).toHaveBeenCalledWith(tester);
            });
        });
    });
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Jasmine_Clock">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Jasmine_Clock">&#182;</a>
      </div>
      <div>

# Jasmine Clock
<p>The <a href="/api/edge/Clock.html">Jasmine Clock</a> is available for testing
time-dependent code.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    describe("Manually ticking the Jasmine Clock", function () {
        let timerCallback;
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-It_is_installed_with_a_call_to_jasmineclockinstall_in_a_spec_or">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-It_is_installed_with_a_call_to_jasmineclockinstall_in_a_spec_or">&#182;</a>
      </div>
      <div>
        <p>It is installed with a call to <code>jasmine.clock().install</code> in a spec or
suite that needs to manipulate time.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}        beforeEach(function () {
            timerCallback = jasmine.createSpy("timerCallback");
            jasmine.clock().install();
        });
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Be_sure_to_uninstall_the_clock_after_you_are_done_to_restore_the">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Be_sure_to_uninstall_the_clock_after_you_are_done_to_restore_the">&#182;</a>
      </div>
      <div>
        <p>Be sure to uninstall the clock after you are done to restore the
original functions.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}        afterEach(function () {
            jasmine.clock().uninstall();
        });
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Mocking_the_JavaScript_Timeout_Functions">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Mocking_the_JavaScript_Timeout_Functions">&#182;</a>
      </div>

## Mocking the JavaScript Timeout Functions
<p>You can make <code>setTimeout</code> or <code>setInterval</code> synchronous executing the
registered functions only once the clock is ticked forward in time.</p>
<p>To execute registered functions, move time forward via the
<code>jasmine.clock().tick</code> function, which takes a number of milliseconds.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}        it("causes a timeout to be called synchronously", function () {
            setTimeout(function () {
                timerCallback();
            }, 100);

            expect(timerCallback).not.toHaveBeenCalled();

            jasmine.clock().tick(101);

            expect(timerCallback).toHaveBeenCalled();
        });

        it("causes an interval to be called synchronously", function () {
            setInterval(function () {
                timerCallback();
            }, 100);

            expect(timerCallback).not.toHaveBeenCalled();

            jasmine.clock().tick(101);
            expect(timerCallback.calls.count()).toEqual(1);

            jasmine.clock().tick(50);
            expect(timerCallback.calls.count()).toEqual(1);

            jasmine.clock().tick(50);
            expect(timerCallback.calls.count()).toEqual(2);
        });
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Mocking_the_Date">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Mocking_the_Date">&#182;</a>
      </div>

## Mocking the Date
<p>The Jasmine Clock can also be used to mock the current date.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}        describe("Mocking the Date object", function () {
            it("mocks the Date object and sets it to a given time", function () {
                const baseTime = new Date(2013, 9, 23);
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-If_you_do_not_provide_a_base_time_to_mockDate_it_will_use">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-If_you_do_not_provide_a_base_time_to_mockDate_it_will_use">&#182;</a>
      </div>
      <div>
        <p>If you do not provide a base time to <code>mockDate</code> it will use
the current date.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}                jasmine.clock().mockDate(baseTime);

                jasmine.clock().tick(50);
                expect(new Date().getTime()).toEqual(baseTime.getTime() + 50);
            });
        });
    });
});


 {% endhighlight %}
    </td>
  </tr>
  </tbody>
</table>
